# 移动语义与完美转发

## 1. 引用

### 1.1 左值与右值

1. **左值与右值**

- 左值具有持久的状态
- 右值要么是字面常量，要么是在表达式求值过程中创建的临时对象，没有持久状态

2. **左右值使用原则**

- 在大多数情况下，需要右值的地方可以用左值来替代
- 需要左值的地方，一定不能用右值来替代

### 1.2 引用

1. **右值解决的问题**

- 临时对象非必要的昂贵的拷贝操作
- 模板函数中如何按照实际类型进行转发

2. **右值引用的特性**

- 右值引用的对象是临时的，即将被销毁
- 右值引用的对象，不会在其他地方使用

以上两个特性意味着: **接受和使用右值引用的代码，可以自由的接管所引用的对象资源，而无需担心其他代码逻辑造成数据破坏**。

从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。右值引用可以直接指向右值，也可以通过 std::move 指向左值；而左值引用只能指向左值。作为函数形参时，右值引用更灵活。

3. **引用对应的类型**

|   引用类型   | 左值 | 常量左值 | 右值 | 常量右值 |      应用场景      |
| :----------: | :--: | :------: | :--: | :------: | :----------------: |
|   左值引用   |  ✔   |    ✘     |  ✘   |    ✘     |                    |
| 常量左值引用 |  ✔   |    ✔     |  ✔   |    ✔     |      拷贝构造      |
|   右值引用   |  ✘   |    ✘     |  ✔   |    ✘     | 移动语义，完美转发 |
| 常量右值引用 |  ✘   |    ✘     |  ✔   |    ✔     |     无实际用途     |

### 1.3 代码示例

- [reference](../code/reference.cc)

## 2. 移动语义

在实际场景中，右值引用和 std::move 被广泛用于在 STL 和自定义类中实现移动语义，避免拷贝，从而提升程序性能。

move 语义的唯一功能是**将一个左值强制转换为一个右值引用**。如果是一些基本类型，比如 int 和 char[10] 定长数组等类型，使用 move 的话仍然会发生拷贝(因为没有对应的移动构造函数)。所以，**move 对于含资源(堆内存或句柄)的对象更有意义**。

一个带有堆内存的类，必须提供一个深拷贝拷贝构造函数，因为默认的拷贝构造函数是浅拷贝，会发生"指针悬挂"的问题。提供深拷贝的拷贝构造函数虽然可以保证正确，但可能会造成额外的性能损耗。

### 2.1 代码示例

- [move](../code/move.cc)

## 3.完美转发

右值引用 T&& 在发生自动类型推断的时候，是一个 universal references，可以接受左值或右值，正是这个特性让他适合作为一个参数路由，然后再通过 std::forward 按照参数的实际类型去匹配对应的重载函数，最终实现完美转发。

### 3.1 代码示例 

- [demo](../code/forward.cc)

## 参考链接

[1] [https://www.jianshu.com/p/d4d068f9f515](https://www.jianshu.com/p/d4d068f9f515)

[2] [https://zhuanlan.zhihu.com/p/107445960](https://zhuanlan.zhihu.com/p/107445960)

[3] [https://www.cnblogs.com/qicosmos/p/4283455.html](https://www.cnblogs.com/qicosmos/p/4283455.html)

[4] [https://blog.51cto.com/u_15346415/3674077](https://blog.51cto.com/u_15346415/3674077)

[5] [https://blog.csdn.net/qq_38410730/article/details/105517378](https://blog.csdn.net/qq_38410730/article/details/105517378)
