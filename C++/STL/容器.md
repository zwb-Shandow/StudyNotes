# 容器

> 用来管理某类对象的集合，各种数据结构

## 1. 序列式容器

> 序列式容器（Sequence containers），此为**可序群集**，其中每个元素均有固定位置—**取决于插入时机和地点，和元素值无关**。如果你以追加方式对一个群集插入六个元素，它们的排列次序将和插入次序一致。STL提供了三个序列式容器：向量（vector）、双端队列（deque）、列表（list），此外也可以把 string 和 array 当做一种序列式容器。

### 1.1 vector

- vector 与 array 唯一区别为空间运用的灵活性，array 是静态空间，一旦配置了就不可改变
- **连续线性空间**
- **动态扩容**，如果超过当时的容量，则容量会扩充至两倍
  - 配置一块更大空间
  - 将原内容拷贝过去
  - 释放原空间

[注]: 尽量在使用 vector 前 reserve 内存，可以避免频繁动态扩容

#### 1.1.1 emplace_back 与 push_back

vector 提供两类增加元素的方法，

- insert/push_back
- emplace/emplace_back

最直接区别为 emplace 类方法支持 vector 内部直接构造数据，减少拷贝或移动。

**a. 源码实现**

```c++
void push_back(const value_type& __x)
{
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
	{
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
	    ++this->_M_impl._M_finish;
	}
	else
	    _M_realloc_insert(end(), __x);
}

void push_back(value_type&& __x)
{
    emplace_back(std::move(__x));
}

#if __cplusplus >= 201103L
template<typename _Tp, typename _Alloc>
template<typename... _Args>
void vector<_Tp, _Alloc>::emplace_back(_Args&&... __args)
{
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
	{
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
	}
	else
	  _M_realloc_insert(end(), std::forward<_Args>(__args)...);
}
#endif
```

可以看出：

1. 当参数是左值时，`push_back` 与 `emplace_back` 的唯一区别是 `emplace_back` 对参数进行了完美转发操作
2. 当参数是右值时，`push_back(T&&)` 调用了 `emplace_back(T&&)`
3. `push_back` 在底层实现时，会优先调用移动构造函数，如果没有才会调用拷贝构造函数

**b. 使用建议:**

- 左值用 `push_back` 与 `emplace_back` 均可，二者无区别
- 右值用 `emplace_back`
- 局部变量尽量使用 `emplace_back` in-place 构建，不要先构建再拷贝或移动

### 1.2 deque

- 动态扩容
- 不保证所有元素都存储到连续的内存空间中

### 1.3 list

- 底层实现为双向链表
- 元素可以分散存储在内存空间里
- 元素顺序通过两个指针维系

### 1.4 时间复杂度

| 容器   | 底层数据结构 | 时间复杂度                             | 是否有序 | 是否可重复 | 适用场景                                                   |
| ------ | ------------ | -------------------------------------- | -------- | ---------- | ---------------------------------------------------------- |
| vector | 数组         | 随机读改、尾部增删 O(1)、头部增删 O(n) | 无序     | 可重复     | 适用于对象简单，变化较小，并且频繁随机访问的场景           |
| deque  | 双端队列     | 头尾增删 O(1)                          | 无序     | 可重复     | 适用于既要频繁随机存取，又要关心两端数据的插入与删除的场景 |
| list   | 双向链表     | 随机插入、删除 O(1)                    | 无序     | 可重复     | 适用于经常进行插入和删除操作并且不经常随机访问的场景       |

## 2. 关联式容器

> 关联式容器（Associative containers），此为**已序群集**，元素位置取决于特定的排序准则以及元素值，和插入次序无关。如果你将六个元素置入这样的群集中，它们的**位置取决于元素值，和插入次序无关**。STL提供了四个关联式容器：集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）。

### 2.1 set

- 所得元素只有 key 没有 value，value 就是 key
- 不允许出现键值重复
- 元素会自动排序(默认升序)
- 不能通过迭代器改变 set 的值

### 2.2 map

- 所有元素都是 key + value
- 不允许键值重复
- 元素通过键进行自动排序
- map 的键不可修改，但是其对应的值可以修改

### 2.3 时间复杂度

| 容器               | 底层数据结构 | 时间复杂度                      | 是否有序 | 是否可重复 | 使用场景 |
| ------------------ | ------------ | ------------------------------- | -------- | ---------- | -------- |
| map                | 红黑树       | 插入、删除、查找 O(log2n)       | 有序     | 不可重复   |          |
| set                | 红黑树       | 插入、删除、查找 O(log2n)       | 有序     | 不可重复   |          |
| multimap           | 红黑树       | 插入、删除、查找 O(log2n)       | 有序     | 可重复     |          |
| multiset           | 红黑树       | 插入、删除、查找 O(log2n)       | 有序     | 可重复     |          |
| unordered_set      | 哈希表       | 插入、删除、查找 O(1) 最差 O(n) | 无序     | 不可重复   |          |
| unordered_multiset | 哈希表       | 插入、删除、查找 O(1) 最差 O(n) | 无序     | 可重复     |          |
| unordered_map      | 哈希表       | 插入、删除、查找 O(1) 最差 O(n) | 无序     | 不可重复   |          |
| unordered_multimap | 哈希表       | 插入、删除、查找 O(1) 最差 O(n) | 无序     | 可重复     |          |

## 3. 容器适配器

> 容器适配器是一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能。之所以称作适配器类，是因为它可以通过适配容器现有的接口来提供不同的功能。STL 提供了三个容器适配器：stack、queue、priority_queue。

### 3.1 stack

- 封装了 deque 容器的适配器类模板
- 默认实现为后入先出(LIFO)的压入栈

### 3.2 queue

- 封装了 deque 容器的适配器类模板
- 默认实现为先入先出(FIFO)的队列

### 3.3 priority_queue

- 封装了 vector 容器的适配器类模板
- 默认实现为降序排序的队列

### 3.4 时间复杂度

| 容器           | 底层数据结构      | 时间复杂度              | 是否有序 | 是否可重复 | 其他                        |
| -------------- | ----------------- | ----------------------- | -------- | ---------- | --------------------------- |
| stack          | deque/list        | 顶部插入、顶部删除 O(1) | 无序     | 可重复     | deque 或 list封闭头端开口   |
| queue          | deque/list        | 头尾增删 O(1)           | 无序     | 可重复     | deque 或 list 封闭头端开口  |
| priority_queue | vector + max-heap | 随机插入、删除 O(1)     | 无序     | 可重复     | vector 容器 + heap 处理规则 |

## 参考链接

[1] [基础篇：STL容器和算法](https://zhuanlan.zhihu.com/p/158647883)

[2] [STL 容器 (一) - 基本介紹](https://jasonblog.github.io/note/c++/stl_rong_qi_4e0029_-_ji_ben_jie_shao.html)

[3] [emplace_back VS push_back](https://blog.csdn.net/u013834525/article/details/104047635)

[4] [C++ STL标准库基础](http://c.biancheng.net/stl/stl_basic/)
