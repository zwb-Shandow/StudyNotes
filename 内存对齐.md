# 内存对齐

## 什么是内存对齐

内存对齐，通常也称为数据对齐，是计算机对数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K(通常是2、4、8、16、32或64)的倍数，即**2的幂次方**。

现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。

## 为什么要进行内存对齐

(1) 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

(2) 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

## 内存对齐规则

每个特定平台上的编译器都有自己默认的”对齐系数”，可以通过设置`#pragma pack(n)`，告诉编译器，所有的对齐都是按照n的整数倍对齐。

在结构体中，整个结构的大小必须是其中最大字段大小的整数倍。

为了让处理器快速读写内存里面的数据，默认情况，编译器会把：

(1) 1个字节的变量，例如`char`类型的变量，放在任意地址的位置上；

(2) 2个字节的变量，例如`short`类型的变量，放在2的整数倍的地址上；

(3) 4个字节的变量，例如`long/float`类型的变量，放在4的整数倍地址上；

(4) 8个字节的变量，例如`long long/uint64_t`或`double`类型的变量，放在8的整数倍地址上；

(5) 16个字节的变量，放在8的整数倍地址上，因为默认的对齐方式是 8。

**变量在内存里面的顺序，和定义变量的顺序相同。为了符合对齐方式，就会在变量之间加入填充字节(padding)，让后面的变量放在按照对齐方式的规则的地址上**。

`struct/class/union`内存对齐规则：

1. 没有`#pragma pack`宏的对齐规则

(1) 结构体的起始存储位置必须是能够被该结构体中最大的数据类型所整除。

(2) 每个数据成员存储的起始位置是自身大小的整数倍(比如int在32位机为4字节，则int型成员要从4的整数倍地址开始存储)。

(3) 结构体总大小(也就是`sizeof`的结果)，必须是该结构体成员中最大的对齐模数的整数倍。若不满足，会根据需要自动填充空缺的字节。

(4) 结构体包含另一个结构体成员，则被包含的结构体成员要从其原始结构体内部最大对齐模数的整数倍地址开始存储(比如`struct a`里存有`struct b`，`b`里有`char`,`int`,`double`等元素,那b应该从8的整数倍开始存储)。

(5) 结构体包含数组成员，比如`char a[3]`,它的对齐方式和分别写3个`char`是一样的，也就是说它还是按一个字节对齐。如果写：`typedef char Array[3]`, `Array`这种类型的对齐方式还是按一个字节对齐，而不是按它的长度3对齐。

(6) 结构体包含共用体成员，则该共用体成员要从其原始共用体内部最大对齐模数的整数倍地址开始存储。

2. 存在`#pragma pack`宏的对齐

(1) `#pragma pack (n)` // 编译器将按照n个字节对齐 

(2) `#pragma pack ()` //取消自定义字节对齐方式

```c++
#pragma pack(push)  // 保存对齐状态
#pragma pack(4)     // 设定为4字节对齐

struct test {
    char m1;
    double m4;
    int m3;
};

#pragma pack(pop)   // 恢复对齐状态
```



可以通过C++11中的`alignas`函数来指定类型、对象或变量按多少字节对齐，可以通过`alignof`函数来判断类型、对象或变量是按多少字节对齐的。

```c++
#include <iostream>

struct X1
{
    int i;
    char c1;
    char c2;
};

struct X2
{
    char c1;
    int i;
    char c2;
};

struct X3
{
    char c1;
    char c2;
    int i;
};

int main()
{
    std::cout << "X1 size: " << sizeof(X1) << "\n"  // 输出8
              << "X2 size: " << sizeof(X2) << "\n"  // 输出12
              << "X3 size: " << sizeof(X3) << std::endl;  // 输出8
}
```